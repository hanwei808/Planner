# 数据类型

> 边界数据类型条件判断问题

- 基础数据类型：存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量
  - undefined
  - Null
  - Boolean
  - String
  - Number
  - Symbol
  - BigInt
- 引用数据类型：存储在堆内存，存储的是地址，多个引用指向同一个地址
  - Object
    - Array
    - RegExp
    - Date
    - Math
    - Function

```js
let a = {
  name: "Julia",
  age: 20,
};

function change(o) {
  // 修改引用地址对象
  o.age = 24;
  // 新对象
  o = {
    name: "Kath",
    age: 30,
  };
  // 返回新地址
  return o;
}

let b = change(a);
console.log(a.age); // 24
console.log(b.age); // 30
```

## 数据类型检测

### typeof

> 可判断基础数据类型（null 除外），不能正确判断引用数据类型（function 除外）

```js
typeof 1; // 'number'
typeof "1"; // 'string'
typeof undefined; // 'undefined'
typeof true; // 'boolean'
typeof Symbol(); // 'symbol'
typeof null; // 'object' 这是 JS BUG
typeof []; // 'object'
typeof {}; // 'object'
typeof console; // 'object'
typeof console.log; // 'function'
```

### instanceof

> 返回对象是否是构造函数生成的对象
> 可判断复杂引用数据类型，不能正确判断基础数据类型

```js
let Car = function () {};
let benz = new Car();
benz instanceof Car; // true

let car = new String("Mercedes Benz");
car instanceof String; // true

let str = "Covid-19";
str instanceof String; // false
```

### Object.prototype.toString

```js
Object.prototype.toString({}); // "[object Object]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call("1"); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(/123/g); // "[object RegExp]"
Object.prototype.toString.call(new Date()); // "[object Date]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(document); // "[object HTMLDocument]"
Object.prototype.toString.call(window); // "[object Window]"
```

```js
function getType(obj) {
  let type = typeof obj;
  // 先进行 typeof 判断，如果是基础数据类型，直接返回
  if (type !== "object") {
    return type;
  }
  // 如果是引用数据类型，使用正则返回结果
  return Object.prototype.toString
    .call(obj)
    .replace(/^\[object (\S+)]\]$/, "$1");
}

// test
getType([]); // "Array"
getType("123"); // "string"
```

## 类型转换

### 强制类型转换

- Number()
  - 布尔值：true 和 false 分别被转换为 1 和 0
  - 数字：返回自身
  - null：返回 0
  - undefined：返回 NaN
  - 字符串
    - 只包含数字：转换为十进制
    - 有效的浮点格式：转换为浮点数值
    - 空字符串：转换为 0
    - 不是以上格式：返回 NaN
- parseInt()
- parseFloat()
- toString()
- String()
- Boolean()
  - 除了 undefined、null、false、''、0、NaN 转换是 false
  - 其他都是 true

### 隐式类型转换

- 逻辑运算符：&&、||、!
- 运算符：+、-、\*、/
- 关系操作符：>、<、<=、>=
- 相等运算符：==
- 条件运算符：if/while

## 拷贝

### 浅拷贝

- object.assign(target, ...sources)

> 不会拷贝对象的继承属性
> 不会拷贝对象的不可枚举属性
> 可以拷贝 Symbol 类型的属性
> 只拷贝对象一层

- 扩展运算符方式
- concat()
- slice()

### 深拷贝

- JSON.stringify()
  - 拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失
  - 拷贝 Date 引用类型会变成字符串
  - 无法拷贝不可枚举的属性
  - 无法拷贝对象的原型链
  - 拷贝 RegExp 引用类型会变成空对象
  - 对象中含有 NaN、Infinity，JSON 序列化的结果会变成 null
  - 无法拷贝对象的循环应用，即对象成环（obj[key] = obj）
- 改进递归实现深拷贝
  - 使用 Reflect.ownKeys 方法，遍历对象的不可枚举属性以及 Symbol 类型
  - 当参数为 Date、RegExp 类型，则直接生成一个新的实例返回
  - 利用 Object 的 getOwnPropertyDescriptors 方法获取对象的所有属性和特性，结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链
  - 利用 WeakMap 类型作为 Hash 表，防止内存泄露，解决循环引用
